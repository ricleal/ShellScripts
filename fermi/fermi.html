
<h2><span class="mw-headline" id="Basic_Requirements_For_API_Implementations">Basic Requirements For API Implementations</span></h2>
<p>The Mantid framework has certain expectations for the API and it's the responsibility of API implementations to meet these expectations:
</p>
<ol>
<li>The API provides a mechanism for executing python scripts in an environment that includes the Mantid framework. (ie: one where "from mantid.simpleapi import *" works)  (Note: exactly *how* this happens is purposely left up to the implementor.)
</li>
<li>Scripts are executed in a batch environment - interactive scripts are not supported and scripts must be able to run without input from the user.
</li>
<li>No mechanism for passing command line parameters to the python scripts is provided. Things like experiment and run numbers must be hard-coded into the script.  (We consider this acceptable because we expect a new script to be auto-generated by MantidPlot for each job.)
</li>
<li>Scripts can write output to what is the current working directory when the script starts.  These output files will be available for download back to MantidPlot (or wherever) once the script finishes.
</li>
<li>Files that were uploaded prior to running the script will be available from the script's working directory.
</li>
<li>Authentication is used to prevent individual users from interfering with others' jobs (or even reading their files)
</li>
<li>Data from the various API calls is returned in two ways: the standard HTTP status codes (200, 404, 500, etc...) and JSON text in the body.  (Note: There's no HTML markup in the output.)  In the case of error status codes, the JSON output will contain a field called 'error_msg' who's value is a string describing the error.
</li>
<li>Clients should assume that all parts of the URL - including query parameters - are case sensitive. However, servers don't *have* to accept URL's with improper case, but may if it makes the code simpler.
</li>
</ol>
<h2><span class="mw-headline" id="Versioning">Versioning</span></h2>
<p>A quick Google search shows that versioning web API's is tricky.  The technique employed here will be to use a major version plus optional extensions.
</p><p>Between major versions there are no guarantees of backwards or forwards compatibility.  Changing the major version is essentially starting over from scratch with a clean slate.  The major version starts at 1 and will hopefully never change.
</p><p>Backwards-compatible changes are handled by means of optional extensions.
</p><p>A server must implement all of the functions defined in the base level of the version and a client may assume those functions exist.  A server is NOT required to implement the extensions (they're optional) and a client may query the server to discover which extensions are implemented.  (Note that what the server returns is really just a name.  It's up to the client and server implementers to agree on exactly what that name means and then document it - presumably here in this API doc.)
</p><p>Backwards-incompatible changes to the API are not allowed.  That includes the URL itself, the GET or POST variables it expects and the JSON that it outputs.  If changes are needed, they can be handled through the extension mechanism.  For example, more GET or POST variables could be accepted by the server, so long as they are not required. An extension should be created (and documented here) so that a client may query the server about whether it supports the new variables.
</p><p>Old GET or POST variables cannot be deleted however. This would break clients that expect to use them.  If there's a case where old varibles no longer make sense, then a completely new URL should be created (and again, documented as an extension).
</p><p>Similar rules apply to the JSON data returned by the API.  Extra fields can be added to the JSON returned by a URL, but original fields may not be removed.
</p><p>It's worth noting that it is possible for extensions to be mutually exclusive.
</p>
<h2><span class="mw-headline" id="Authentication">Authentication</span></h2>
<p>The initial API uses HTTP Basic-Auth name/password combo for authentication.  (Other methods may be added via API extensions as described above.)  Upon successful authentication, a session cookie is created.  All other URL's require this session cookie.
</p><p>Because the Basic-Auth scheme does not encrypt the password when it is sent to the server, the use of the HTTPS protocol is <b>STRONGLY</b> encouraged.
</p><p>Note that HTTP Basic-Auth is simply the mechanism for passing a username/password combo to the web service.  Exactly how the web service uses that combo to authenticate (and authorize) a user is not specified by the API.  Individual implementations are free to do what they like.  (For example, the implementation on Fermi checks the username &amp; password against an LDAP server.)
</p>
<h2><span class="mw-headline" id="Transactions">Transactions</span></h2>
<p>The API details below mention starting &amp; stopping transactions.  It should be noted that in this context, the word transaction doesn't really have anything to do with databases.  In this context, transactions are a mechanism for the web service to associate files with specific jobs. Multiple jobs may be submitted under a given transaction.
</p><p>Note that the API doesn't specify how this association occurs.  That is a detail left up to the individual implementation.
However, remember the points in the Basic Requirements section above about scripts reading from and writing to their current working directory while not allowing other users to see or modify their files.  That implies that each job will store files in its own directory and will execute scripts from that directory.  (This is, in fact, how the implementation on Fermi works.)
</p><p>A user must start a transaction after authenticating, but before transferring files or submitting job scripts.  When the user's job (or jobs) has finished and the user no longer needs the files associated with the transaction, he or she should end the transaction.  This will allow the web service to delete the files and recover the disk space.
</p>
<h2><span class="mw-headline" id="A_Note_About_File_Uploads">A Note About File Uploads</span></h2>
<p>It is generally assumed that the input files for the submitted python scripts are already available on the compute resource (presumably via some kind of network filesystem).  Thus, although the API allows for file uploads, this is really intended for relatively small support files that a particular script might need.  The HTTP protocol really isn't intended or suitable for transferring the sort of multi-gigabyte files that are likely to be the inputs for these python scripts.
</p>
<h2><span class="mw-headline" id="API_v1_URL.27s">API v1 URL's</span></h2>
<p>General notes:
</p>
<ul>
<li>All URL's expect GET requests unless otherwise noted.
</li>
<li>The session cookie returned by the authentication URL is required by all other URL's (except for the info URL)
</li>
<li>Success is indicated by an HTTP status code in the 200 range.  (Typically, 200, but in some cases 201.)  Errors are indicated with error codes in the 400 and 500 range.
</li>
<li>In the case of errors, the JSON output will include a field named "Err_Msg" whose value is a text string describing the particular error.
</li>
</ul>
<p><br>
</p>
<h3><span class="mw-headline" id="Information">Information</span></h3>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Returns information about the server including the API version and supported extensions.
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/info
</td></tr>
<tr>
<td>Query Parameters </td>
<td> None
</td></tr>
<tr>
<td>JSON Output </td>
<td>
<p>API_Version&nbsp;: &lt;integer&gt;<br>
API_Extensions&nbsp;: [ &lt;extension_1&gt;, &lt;extensions_2&gt;, .... ]<br>
Implementation_Specific_Post_Variables&nbsp;: [ &lt;variable_1&gt;, &lt;variable_2&gt;, .... ]
</p>
</td></tr>
<tr>
<td>Notes </td>
<td>
<p>May be called without first authenticating.<br>
The 'Implementation_Specific_Submit_Variables' field lists the particular POST variables that this implementation requires when submitting a job.  See the <a href="http://www.mantidproject.org/Remote_Job_Submission_API#Job_Submission">Job Submission</a> URL.
</p>
</td></tr></tbody></table>
<p><br>
</p>
<h3><span class="mw-headline" id="Authentication_2">Authentication</span></h3>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Authenticate to the web service.
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/authenticate
</td></tr>
<tr>
<td>Query Parameters </td>
<td> None
</td></tr>
<tr>
<td>JSON Output </td>
<td> None
</td></tr>
<tr>
<td>Notes </td>
<td> Username and password are passed in using HTTP Basic Authentication
<p>Returns a session cookie which must be passed to the other URL's
</p>
</td></tr></tbody></table>
<p><br>
</p>
<h3><span class="mw-headline" id="Transactions_2">Transactions</span></h3>
<p>This URL has two forms: one to start a new transaction and the other to end an existing transaction.
</p>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Start a new transaction
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/transaction
</td></tr>
<tr>
<td>Query Parameters </td>
<td> Action=Start
</td></tr>
<tr>
<td>JSON Output </td>
<td> TransID&nbsp;: &lt;string&gt;
</td></tr>
<tr>
<td>Notes </td>
<td>
</td></tr></tbody></table>
<p><br>
</p>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> End an existing transaction
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/transaction
</td></tr>
<tr>
<td>Query Parameters </td>
<td> Action=Stop<br>TransID=&lt;transaction_id&gt;
</td></tr>
<tr>
<td>JSON Output </td>
<td> None
</td></tr>
<tr>
<td>Notes </td>
<td> Once a transaction is stopped, any files associated with it will no longer be available for download and the server is free to delete those files.
</td></tr></tbody></table>
<p><br>
</p>
<h3><span class="mw-headline" id="File_Transfer">File Transfer</span></h3>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Transfer a file from the server back to the client
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/download
</td></tr>
<tr>
<td>Query Parameters </td>
<td> TransID=&lt;transaction ID&gt; <br> File=&lt;filename&gt;
</td></tr>
<tr>
<td>JSON Output </td>
<td>
</td></tr>
<tr>
<td>Notes </td>
<td> &lt;filename&gt;  does not include any path information.  The actual directory where the file is stored is chosen by the web service and hidden from the user
</td></tr></tbody></table>
<p><br>
</p>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Transfer one or more files from the client up to the server
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/upload
</td></tr>
<tr>
<td>Query Parameters </td>
<td> None
</td></tr>
<tr>
<td>JSON Output </td>
<td> None
</td></tr>
<tr>
<td>Notes </td>
<td>
<p>This is a POST method<br>
Multiple files may be submitted with one call<br>
File(s) are submitted as multipart form data (ie: "Content-Type: multipart/form-data" header)<br>
File names should not include any directory or path information.  (Exactly where the file is stored is left to the web service to determine.)<br>
The transaction ID must also be specified as form data with a field name of "TransID"<br>
On success, returns a "201 - Created" status code
</p>
</td></tr></tbody></table>
<p><br>
</p>
<h3><span class="mw-headline" id="File_Listing">File Listing</span></h3>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Return a listing of files associated with the specified transaction
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/files
</td></tr>
<tr>
<td>Query Parameters </td>
<td>TransID=&lt;transaction ID&gt;
</td></tr>
<tr>
<td>JSON Output </td>
<td> Files&nbsp;: [ &lt;file_1&gt;, &lt;file_2&gt;, ... &lt;file_n&gt; ]
</td></tr>
<tr>
<td>Notes </td>
<td> No guarantees are made about the order files are listed
</td></tr></tbody></table>
<p><br>
</p>
<h3><span class="mw-headline" id="Job_Submission">Job Submission</span></h3>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Submit a python script for execution on the compute resource
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/submit
</td></tr>
<tr>
<td>Query Parameters </td>
<td> None
</td></tr>
<tr>
<td>Mandatory POST Variables </td>
<td>
<p>TransID&nbsp;: &lt;trans_id&gt;<br>
ScriptName&nbsp;: &lt;name_of_python_script&gt;<br>
&lt;name_of_python_script&gt;&nbsp;: &lt;python code&gt;
</p>
</td></tr>
<tr>
<td>Optional POST Variables </td>
<td>
<p>JobName&nbsp;: &lt;name&gt;
</p>
</td></tr>
<tr>
<td>Implementation Specific POST Variables </td>
<td>
<p>NumNodes&nbsp;: &lt;number_of_nodes&gt;<br>
CoresPerNode: &lt;cores_per_node&gt;
</p>
</td></tr>
<tr>
<td>JSON Output </td>
<td> JobID&nbsp;: &lt;job_id&gt;
</td></tr>
<tr>
<td>Notes </td>
<td>
<p>This is a POST method<br>
Request is submitted as multipart form data (ie: "Content-Type: multipart/form-data" header)<br>
POST variables listed above are individual form data fields<br>
The content of the "ScriptName" field specifies the name of the python script.  There must be another field with this name that actually contains the python code.  This allows the web service to keep track of multiple scripts associated with the same transaction.<br>
The JobName variable allows the user to specify a name for a job.  The name is included in the output of queries.  (Presumably, the user will pick a name that's more descriptive and easier to remember than the automatically assigned job ID.)<br>
The Implementation Specific Post Variables are - like the name says - specific to a particular implementation.  They may not be applicable to all implementations and it's valid for an implementation to ignore those that aren't.  Which variables are required by a specific implementation are listed in the <a href="http://www.mantidproject.org/Remote_Job_Submission_API#Information">Information</a> URL.  (The two specified above are used by the Fermi implementation, and would probably be valid for all compute clusters.)
</p>
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Job_Query">Job Query</span></h3>
<p>This URL has two forms: one to query a specific job and one to query all of a user's jobs.
</p>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Query all jobs submitted by the user
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/query
</td></tr>
<tr>
<td>Query Parameters </td>
<td> None
</td></tr>
<tr>
<td>JSON Output </td>
<td>
<p>&lt;job_id&gt;&nbsp;: &lt;job_description_object&gt;<br>
&lt;job_id&gt;&nbsp;: &lt;job_description_object&gt;<br>
&lt;job_id&gt;&nbsp;: &lt;job_description_object&gt;<br>
etc...
</p>
</td></tr>
<tr>
<td>Notes </td>
<td> See below for a description of the job_description_object<br>
<p>The length of time the compute resource will 'remember' jobs is up to the implementer, but several days should be considered an absolute minimum.  (A user should be able to submit a job on Friday and still be able to query it on Monday morning.)
</p>
</td></tr></tbody></table>
<p><br>
</p>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Query one specific job submitted by the user
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/query
</td></tr>
<tr>
<td>Query Parameters </td>
<td> JobID&nbsp;: &lt;job_id&gt;
</td></tr>
<tr>
<td>JSON Output </td>
<td> &lt;job_id&gt;&nbsp;: &lt;job_description_object&gt;
</td></tr>
<tr>
<td>Notes </td>
<td> See below for a description of the job_description_object<br>
<p>The length of time the compute resource will 'remember' jobs is up to the implementer, but several days should be considered an absolute minimum.  (A user should be able to submit a job on Friday and still be able to query it on Monday morning.)
</p>
</td></tr></tbody></table>
<p>The job description object is a JSON object who's fields contain specific information about the job.  The fields are:
</p>
<ul>
<li>TransID - The transaction ID the job is associated with
</li>
<li>JobName - The name that was given to the submit API
</li>
<li>ScriptName - The name of the python script that was executed
</li>
<li>JobStatus - The execution status of the job.  Will be one of: RUNNING, QUEUED, COMPLETED, REMOVED, DEFERRED, IDLE or UNKNOWN
</li>
</ul>
<h3><span class="mw-headline" id="Job_Abort">Job Abort</span></h3>
<table border="1">
<tbody><tr>
<td>Description </td>
<td> Abort a previously submitted job.  Jobs that are queued will be dequeued.  Jobs that are running will be stopped immediately.  Jobs that have already completed will simply be ignored.
</td></tr>
<tr>
<td>URL </td>
<td> &lt;base_url&gt;/abort
</td></tr>
<tr>
<td>Query Parameters </td>
<td> JobID&nbsp;: &lt;job_id&gt;
</td></tr>
<tr>
<td>JSON Output </td>
<td> None
</td></tr>
<tr>
<td>Notes </td>
<td> Returns a 400 error code if the job ID does not exist.
</td></tr></tbody></table>
<h2><span class="mw-headline" id="API_v1_Extensions">API v1 Extensions</span></h2>
<h3><span class="mw-headline" id="JOB_DATES">JOB_DATES</span></h3>
<p>The JOB_DATES extension adds three fields to the job_description_object that is returned by queries.  The fields are "SubmitDate", "StartDate" &amp; "CompletionDate" which represent the dates (including time) that the job was first submitted, when it started executing and when it stopped (either because it finished or because it was interrupted for some reason).  The values are ISO8601 strings suitable for importing into a Mantid DateAndTime object.
</p>
<h3><span class="mw-headline" id="AUTH_USER_NAME">AUTH_USER_NAME</span></h3>
<p>The AUTH_USER_NAME extension adds a single field the the JSON text returned by the 'info' URL.  The field name is 'Authenticated_As' and its value is either the name of the user that's been authenticated, or empty if no authentication has taken place yet.
</p>
